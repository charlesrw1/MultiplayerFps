#version 430 core

layout(local_size_x = 8, local_size_y=8,local_size_z=1) in;
layout(rgba16f,binding =2) uniform image3D VolumeTexture;

#define PI 3.14159

float ComputeScattering(float lightDotView)
{
	float scattering = 0.001;
	float result=1.0-scattering*scattering;
	result /= (4.0*PI*pow(1.0+scattering*scattering-(2.0*scattering)*lightDotView,1.5));
	return result;
}

float phase_function(vec3 Wo, vec3 Wi, float g)
{
    float cos_theta = dot(Wo, Wi);
    float denom     = 1.0 + g * g + 2.0 * g * cos_theta;
    return (1.0 / (4.0 * PI)) * (1.0 - g * g) / max(pow(denom, 1.5), 0.0001);
}

struct Vfog_Light
{
	vec4 position_type;
	vec4 color;
	vec4 direction_coneangle;
};
struct Vfog_Params
{
	ivec4 volumesize;
	vec4 spread_frustumend;
};

layout (binding = 3, std140) readonly buffer Lights {
  Vfog_Light lights[];
};
layout (binding = 4, std140) uniform Vfog_Param_Buffer {
	Vfog_Params fogparam;
};

uniform int num_lights = 0;
uniform vec3 ambient = vec3(0.02);


uniform mat4 InvProjection;
uniform mat4 InvView;
uniform vec3 ViewPos;

uniform float znear;
uniform float zfar;
uniform float density;
uniform float anisotropy;

uniform ivec3 TextureSize;

vec4 ScreenToView(vec4 screenspace)
{
	vec4 clipspace = vec4(1);
	clipspace.z = 0;
	clipspace.xy = screenspace.xy*0.5 - vec2(0.5);
	
	vec4 viewspace = InvProjection*clipspace;
	viewspace = viewspace / viewspace.w;
	return viewspace;
}
vec3 ViewToWorld(vec4 viewspace)
{
	vec4 world = InvView*viewspace;
	world = world/world.w;
	return world.xyz;
}

vec3 LineIntersectionToZPlane(vec3 A, vec3 B, float zplane)
{
	vec3 normal = vec3(0.0,0.0,-1.0);
	vec3 ab = B-A;
	float t = (zplane-dot(normal,A))/dot(normal,ab);
	return A + t*ab;
}

vec3 randColor(int number){
    return fract(sin(vec3(number+1)*vec3(12.8787, 1.97, 20.73739)));
}

vec3 get_worldpos()
{
	ivec3 fragcoords = ivec3(gl_GlobalInvocationID.xyz);
	vec3 invpixelsize = 1/vec3(TextureSize);
	vec3 screencoord = vec3(fragcoords)*invpixelsize;
	vec4 point_ss = vec4(vec2(screencoord.x,screencoord.y)+vec2(0.5)*invpixelsize.xy,-1.0,1.0);
	vec4 point_vs = ScreenToView(point_ss);
	
	float tilez = znear*pow(zfar/znear,screencoord.z);
	
	vec3 viewspace_point = LineIntersectionToZPlane(vec3(0.0),point_vs.xyz,tilez);
	
	vec3 worldpos = ViewToWorld(vec4(viewspace_point,1.0));
	
	return worldpos;
}

void main()
{
	ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);
	vec3 fog_cell_size = 1/vec3(fogparam.volumesize);
	vec3 posf = vec3(pos);
	vec3 fog_unit_pos = posf*fog_cell_size + fog_cell_size*0.5;
	//fog_unit_pos.z = pow(fog_unit_pos.z, fogparam.spread_frustumend.x); // fog_unit_pos: [0,1]
	
	vec3 viewspace = ScreenToView(vec4(fog_unit_pos.xy,0,1)).xyz;
	viewspace.z = -fog_unit_pos.z*100.0;
	vec3 worldpos = ViewToWorld(vec4(viewspace,1.0));
	

	vec3 raydir = normalize(worldpos.xyz-ViewPos);
	vec3 inscattering = vec3(0.0);
#if 1
	for(int light_index=0;light_index<1;light_index++) {
		int type = int(lights[light_index].position_type.w);
		vec3 position = lights[light_index].position_type.xyz;
		vec3 color = lights[light_index].color.rgb;
		vec3 l = worldpos.xyz-position;
		float dist = length(l);
		float phase = phase_function(raydir, l, anisotropy);
		l /= dist;
		if(type == 0) {
			inscattering = vec3(10.0/(dist*dist*dist*dist));
		}
		else {
			vec3 dir = lights[light_index].direction_coneangle.xyz;
			float angle = lights[light_index].direction_coneangle.w;
			if(dot(-l,dir) > angle) {
				inscattering+=phase*color/(dist*dist) * 10.0;
			}
		}
	}
#endif
	//inscattering += ambient;

	//float edensity = exp(-density);
	vec4 coloranddensity = vec4(inscattering,density);
	
	int id = int(gl_GlobalInvocationID.x)*20*12 + int(gl_GlobalInvocationID.y)*12 +int(gl_GlobalInvocationID.z);
	vec3 rand_c = randColor(id);
	
	if(worldpos.x<0)worldpos.x=0;
	else worldpos.x = 1.0;
	if(worldpos.y<0)worldpos.y=0;
	else worldpos.y = 1.0;
	if(worldpos.z<0)worldpos.z=0;
	else worldpos.z = 1.0;



	imageStore(VolumeTexture,pos,vec4(get_worldpos().xyzx));
}