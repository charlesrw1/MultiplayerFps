#version 430 core

layout(local_size_x = 8, local_size_y=8,local_size_z=1) in;
layout(rgba16f,binding =2) uniform image3D VolumeTexture;

#define PI 3.14159

float ComputeScattering(float lightDotView)
{
	float scattering = 0.001;
	float result=1.0-scattering*scattering;
	result /= (4.0*PI*pow(1.0+scattering*scattering-(2.0*scattering)*lightDotView,1.5));
	return result;
}

float phase_function(vec3 Wo, vec3 Wi, float g)
{
    float cos_theta = dot(Wo, Wi);
    float denom     = 1.0 + g * g + 2.0 * g * cos_theta;
    return (1.0 / (4.0 * PI)) * (1.0 - g * g) / max(pow(denom, 1.5), 0.0001);
}

struct Vfog_Light
{
	vec4 position_type;
	vec4 color;
	vec4 direction_coneangle;
};
struct Vfog_Params
{
	ivec4 volumesize;
	vec4 spread_frustumend;
};

layout (binding = 3, std140) readonly buffer Lights {
  Vfog_Light lights[];
};
layout (binding = 4, std140) uniform Vfog_Param_Buffer {
	Vfog_Params params;
}

uniform int num_lights = 0;
uniform vec3 ambient = vec3(0.02);


uniform mat4 InvProjection;
uniform mat4 InvView;
uniform vec3 ViewPos;
uniform ivec3 TextureSize;
uniform float fog_depth_spread=1.0;
uniform float fog_frustum_end;

uniform float znear;
uniform float zfar;
uniform float density;
uniform float anisotropy;

float get_depth_at_pos(float cell_depth, int z)
{
	float d = float(z)*cell_depth + cell_depth*0.5;	// d: [0,1]
	d = pow(d, depth_spread);
	return d*fog_frustum_end;
}

vec4 ScreenToView(vec4 screenspace)
{
	vec4 clipspace = vec4(vec2(screenspace.xy)*2.0-vec2(1.0),screenspace.z,screenspace.w);
	
	vec4 viewspace = InvProjection*clipspace;
	viewspace = viewspace / viewspace.w;
	return viewspace;
}
vec3 ViewToWorld(vec4 viewspace)
{
	vec4 world = InvView*viewspace;
	world = world/world.w;
	return world.xyz;
}

vec3 LineIntersectionToZPlane(vec3 A, vec3 B, float zplane)
{
	vec3 normal = vec3(0.0,0.0,-1.0);
	vec3 ab = B-A;
	float t = (zplane-dot(normal,A))/dot(normal,ab);
	return A + t*ab;
}

vec3 randColor(int number){
    return fract(sin(vec3(number+1)*vec3(12.8787, 1.97, 20.73739)));
}

void main()
{
	ivec3 fragcoords = ivec3(gl_GlobalInvocationID.xyz);
	vec3 invpixelsize = 1/vec3(TextureSize);
	vec3 screencoord = vec3(fragcoords)*invpixelsize;
	vec4 point_ss = vec4(vec2(screencoord.x,screencoord.y)+vec2(0.5)*invpixelsize.xy,-1.0,1.0);
	vec4 point_vs = ScreenToView(point_ss);
	float tilez = znear*pow(zfar/znear,screencoord.z);
	vec3 viewspace_point = LineIntersectionToZPlane(vec3(0.0),point_vs.xyz,tilez);
	vec3 worldpos = ViewToWorld(vec4(viewspace_point,1.0));
	vec3 raydir = normalize(worldpos-ViewPos);
	vec3 inscattering = vec3(0.0);
#if 1
	for(int light_index=0;light_index<1;light_index++) {
		int type = int(lights[light_index].position_type.w);
		vec3 position = lights[light_index].position_type.xyz;
		vec3 color = lights[light_index].color.rgb;
		vec3 l = worldpos-position;
		float dist = length(l);
		float phase = phase_function(raydir, l, anisotropy);
		l /= dist;
		if(type == 0) {
			inscattering+=phase*color/(dist*dist);
		}
		else {
			vec3 dir = lights[light_index].direction_coneangle.xyz;
			float angle = lights[light_index].direction_coneangle.w;
			if(dot(-l,dir) > angle) {
				inscattering+=phase*color/(dist*dist);
			}
		}
	}
#endif
	inscattering += ambient;

	//float edensity = exp(-density);
	vec4 coloranddensity = vec4(inscattering,density);
	
	int id = int(gl_GlobalInvocationID.x)*20*12 + int(gl_GlobalInvocationID.y)*12 +int(gl_GlobalInvocationID.z);
	vec3 rand_c = randColor(id);
	imageStore(VolumeTexture,ivec3(fragcoords),coloranddensity);
}