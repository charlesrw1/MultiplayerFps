#version 430 core

layout(local_size_x = 8, local_size_y=8,local_size_z=1) in;
layout(rgba16f,binding =2) uniform image3D  VolumeTexture;

uniform sampler3D previous_volume;

#define PI 3.14159

float ComputeScattering(float lightDotView)
{
	float scattering = 0.001;
	float result=1.0-scattering*scattering;
	result /= (4.0*PI*pow(1.0+scattering*scattering-(2.0*scattering)*lightDotView,1.5));
	return result;
}

float phase_function(vec3 Wo, vec3 Wi, float g)
{
    float cos_theta = dot(Wo, Wi);
    float denom     = 1.0 + g * g + 2.0 * g * cos_theta;
    return (1.0 / (4.0 * PI)) * (1.0 - g * g) / max(pow(denom, 1.5), 0.0001);
}

struct Vfog_Params
{
	ivec4 volumesize;
	vec4 spread_frustumend;
	vec4 reprojection;
	mat4 last_viewproj;
};
layout (binding = 4, std140) uniform Vfog_Param_Buffer {
	Vfog_Params fogparam;
};


uniform mat4 InvProjection;
uniform mat4 InvView;
uniform vec3 ViewPos;
uniform ivec3 TextureSize;

uniform float znear;
uniform float zfar;
uniform float density;
uniform float anisotropy;

vec4 ScreenToView(vec4 screenspace)
{
	vec4 clipspace = vec4(vec2(screenspace.xy)*2.0-vec2(1.0),screenspace.z,screenspace.w);
	
	vec4 viewspace = InvProjection*clipspace;
	viewspace = viewspace / viewspace.w;
	return viewspace;
}
vec3 ViewToWorld(vec4 viewspace)
{
	vec4 world = InvView*viewspace;
	world = world/world.w;
	return world.xyz;
}

vec3 LineIntersectionToZPlane(vec3 A, vec3 B, float zplane)
{
	//vec3 normal = vec3(0.0,0.0,-1.0);
	//vec3 ab = B-A;
	//float t = (zplane-dot(normal,A))/dot(normal,ab);
	//return A + t*ab;

	// why is this working...
	float t = zplane/(-B.z);
	return B*t;
}

vec3 randColor(int number){
    return fract(sin(vec3(number+1)*vec3(12.8787, 1.97, 20.73739)));
}

uniform vec3 spotlightpos;
uniform vec3 spotlightnormal;
uniform float spotlightangle;
uniform vec3 spotlightcolor;

#define TEMPORAL_FRAMES 16
const vec3 halton_map[TEMPORAL_FRAMES] = vec3[](
		vec3(0.5, 0.33333333, 0.2),
		vec3(0.25, 0.66666667, 0.4),
		vec3(0.75, 0.11111111, 0.6),
		vec3(0.125, 0.44444444, 0.8),
		vec3(0.625, 0.77777778, 0.04),
		vec3(0.375, 0.22222222, 0.24),
		vec3(0.875, 0.55555556, 0.44),
		vec3(0.0625, 0.88888889, 0.64),
		vec3(0.5625, 0.03703704, 0.84),
		vec3(0.3125, 0.37037037, 0.08),
		vec3(0.8125, 0.7037037, 0.28),
		vec3(0.1875, 0.14814815, 0.48),
		vec3(0.6875, 0.48148148, 0.68),
		vec3(0.4375, 0.81481481, 0.88),
		vec3(0.9375, 0.25925926, 0.12),
		vec3(0.03125, 0.59259259, 0.32));



ivec3 fragcoords;
vec3 invpixelsize;

vec3 get_worldpos_new(vec3 poffset)
{
	vec3 screencoord = vec3(fragcoords)*invpixelsize + poffset*invpixelsize;
	vec4 point_ss = vec4(vec2(screencoord.x,screencoord.y),-1.0,1.0);
	vec4 point_vs = ScreenToView(point_ss);
	screencoord.z = pow(screencoord.z, fogparam.spread_frustumend.x);
	float tilez = screencoord.z*fogparam.spread_frustumend.y+znear;
	vec3 viewspace_point = point_vs.xyz*tilez/(-point_vs.z);
	return ViewToWorld(vec4(viewspace_point,1.0));
}

float linearize_depth(float d,float zNear,float zFar)
{
    float z_n = 2.0 * d - 1.0;
    return 2.0 * zNear * zFar / (zFar + zNear - z_n * (zFar - zNear));
}

vec4 get_previous_tex(vec3 NDC)
{
	float lineardepth = linearize_depth(NDC.z*0.5+0.5,znear,zfar);
	vec3 texturecoord = vec3((NDC.xy+vec2(1.0))*0.5,0.0);
	texturecoord.z = pow((lineardepth-znear) / fogparam.spread_frustumend.y,1.0/fogparam.spread_frustumend.x);
	return texture(previous_volume,texturecoord);
}

void main()
{
	fragcoords = ivec3(gl_GlobalInvocationID.xyz);
	invpixelsize = 1/vec3(fogparam.volumesize);

	vec3 worldpos = get_worldpos_new(vec3(0.5));

	// calc reprojection
	vec4 reprojected_ndc = fogparam.last_viewproj*vec4(worldpos,1.0);
	vec4 reprojected_value = vec4(0.0);
	float reprojected_mix = 0.95;
	reprojected_ndc/=reprojected_ndc.w;
	if (all(greaterThan(reprojected_ndc.xyz, vec3(-1.0))) && all(lessThan(reprojected_ndc.xyz, vec3(1.0)))) {
		// good reprojection
		reprojected_value = get_previous_tex(reprojected_ndc.xyz);
		worldpos = get_worldpos_new(halton_map[int(fogparam.reprojection.x)]);
	}
	else
		reprojected_mix = 0.0;
	
	
	
	vec3 raydir = normalize(worldpos-ViewPos);
	vec3 inscattering = vec3(0.0);
	
	vec3 spotdir = worldpos-spotlightpos;
	float spotlen = length(spotdir);
	spotdir = spotdir/spotlen;
	vec3 spotadd = vec3(0.05);
	//if(dot(spotdir,spotlightnormal)>spotlightangle) {
		spotadd = phase_function(raydir,spotdir,anisotropy)*vec3(5,4,10)*20.0/(spotlen*spotlen);
		spotadd = min(spotadd, 50.0);
	//}
	inscattering += spotadd;
	
	
	float edensity = exp(-density);
	vec4 coloranddensity = vec4(inscattering*edensity,edensity);
	//ComputeScattering(dot(raydir,-sun_dir));
	
	
	coloranddensity = mix(coloranddensity, reprojected_value, reprojected_mix);
	
	imageStore(VolumeTexture,ivec3(fragcoords),coloranddensity);//vec4(inscattering,density));
}