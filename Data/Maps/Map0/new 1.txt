

struct ObjectData
{
	mat4 transform;
	vec4 sphere_and_radius;
};


struct DrawElementsIndirect
{
	uint  count;
	uint  primCount;
	uint  firstIndex;
	int   baseVertex;
	uint  baseInstance;
};

// primitives in meshlet = 64
struct Meshlet_Header
{
	uint index_buffer_offset;
	vec3 bboxcenter;
	vec3 bbox;
	uint normal_and_sin;
};

struct Mesh_Obj
{
	uint meshlet_count;
	uint meshlet_start;
};

struct Drawcall
{
	mat4 transform;
	int meshindex;
};

// each mesh obj gets mapped to one DrawElementsIndirect call
// intermediate data
struct Mesh_Obj_Counters
{
	uint surviving_count = 0;	
	uint surviving_start = 0;
	
	uint surviving_cluster_count = 0;
	uint surviving_cluster_start = 0;
	
	uint surviving_index_count = 0;
	uint surviving_index_start = 0;
};

struct Meshlet_Working_Args
{
	uint object_index;
	uint cluster_index;
};

struct ClusterVisMask
{
	byte masks[128];
};

struct TriangleVisMask
{
	byte masks[8];
};

NUM_UNIQUE_MESHES = X;
NUM_MESHLETS = sum(number of meshlets per unique mesh);

Mesh_Obj_Counters mesh_obj_counters = [NUM_UNIQUE_MESHES];
Mesh_Obj mesh_obj = [NUM_UNIQUE_MESHES];
DrawElementsIndirect drawcmds = [NUM_UNIQUE_MESHES];
Meshlet_Header meshlets = [NUM_MESHLETS];

NUM_DRAW_CALLS = Y;
NUM_SCENE_OBJECTS = Z; (Z<=Y)

ObjectData objects = [NUM_SCENE_OBJECTS];
Drawcall draw_calls = [NUM_DRAW_CALLS];

NUM_INDICIES_TOTAL = sum(all drawcmds index counts);
uint index_to_object = [NUM_INDICIES_TOTAL];

// this is created after object culling, where each holds the object index and cluster index
Meshlet_Working_Args meshlet_culling = [];

// these buffers can all be "shared"
uint mesh_prefix_sum = [];
uint cluster_prefix_sum = [];
uin triang




